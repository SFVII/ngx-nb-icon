import { Color } from './color';
class Solver {
    constructor(target, options) {
        this.target = target;
        this.targetHSL = target.hsl();
        this.options = Object.assign({}, 
        // Adding default values for options
        {
            acceptanceLossPercentage: 5,
            maxChecks: 15,
        }, options);
        // All the calcs done by the library to generate
        // a CSS Filter are based on the color `#000`
        // in this case, `rgb(0, 0, 0)`
        // Please make sure the background of the element
        // is `#000` for better performance
        // and color similarity.
        this.reusedColor = new Color(0, 0, 0);
    }
    /**
     * Returns the solved values for the
     *
     * @returns {(SPSAPayload & { filter: string; })}
     * @memberof Solver
     */
    solve() {
        const result = this.solveNarrow(this.solveWide());
        return {
            values: result.values,
            called: result.called,
            loss: result.loss,
            filter: this.css(result.values),
        };
    }
    /**
     * Solve wide values based on the wide values for RGB and HSL values
     *
     * @private
     * @returns {SPSAPayload}
     * @memberof Solver
     */
    solveWide() {
        const A = 5;
        const c = 15;
        // Wide values for RGB and HSL values
        // the values in the order: [`r`, `g`, `b`, `h`, `s`, `l`]
        const a = [60, 180, 18000, 600, 1.2, 1.2];
        let best = { loss: Infinity };
        let counter = 0;
        while (best.loss > this.options.acceptanceLossPercentage) {
            const initialFilterValues = [50, 20, 3750, 50, 100, 100];
            const result = this.spsa({
                A,
                a,
                c,
                values: initialFilterValues,
                // for wide values we should use the double of tries in
                // comparison of `solveNarrow()` method
                maxTriesInLoop: 1000,
            });
            if (result.loss < best.loss) {
                best = result;
            }
            counter += 1;
            if (counter >= this.options.maxChecks) {
                break;
            }
        }
        return Object.assign({}, best, { called: counter });
    }
    /**
     * Solve narrow values based on the wide values for the filter
     *
     * @private
     * @param {SPSAPayload} wide
     * @returns {SPSAPayload}
     * @memberof Solver
     */
    solveNarrow(wide) {
        const A = wide.loss;
        const c = 2;
        const A1 = A + 1;
        // Narrow values for RGB and HSL values
        // the values in the order: [`r`, `g`, `b`, `h`, `s`, `l`]
        const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
        return this.spsa({
            A,
            a,
            c,
            values: wide.values,
            maxTriesInLoop: 500,
            called: wide.called,
        });
    }
    /**
     * Returns final value based on the current filter order
     * to get the order, please check the returned value
     * in `css()` method
     *
     * @private
     * @param {number} value
     * @param {number} idx
     * @returns {number}
     * @memberof Solver
     */
    fixValueByFilterIDX(value, idx) {
        let max = 100;
        // Fixing max, minimum and value by filter
        if (idx === 2 /* saturate */) {
            max = 7500;
        }
        else if (idx === 4 /* brightness */ || idx === 5 /* contrast */) {
            max = 200;
        }
        if (idx === 3 /* hue-rotate */) {
            if (value > max) {
                value %= max;
            }
            else if (value < 0) {
                value = max + (value % max);
            }
        }
        // Checking if value is below the minimum or above
        // the maximum allowed by filter
        else if (value < 0) {
            value = 0;
        }
        else if (value > max) {
            value = max;
        }
        return value;
    }
    spsa({ A, a, c, values, maxTriesInLoop = 500, called = 0, }) {
        const alpha = 1;
        const gamma = 0.16666666666666666;
        let best = null;
        let bestLoss = Infinity;
        const deltas = new Array(6);
        const highArgs = new Array(6);
        const lowArgs = new Array(6);
        // Size of all CSS filters to be applied to get the correct color
        const filtersToBeAppliedSize = 6;
        for (let key = 0; key < maxTriesInLoop; key++) {
            const ck = c / Math.pow(key + 1, gamma);
            for (let i = 0; i < filtersToBeAppliedSize; i++) {
                deltas[i] = Math.random() > 0.5 ? 1 : -1;
                highArgs[i] = values[i] + ck * deltas[i];
                lowArgs[i] = values[i] - ck * deltas[i];
            }
            const lossDiff = this.loss(highArgs) - this.loss(lowArgs);
            for (let i = 0; i < filtersToBeAppliedSize; i++) {
                const g = (lossDiff / (2 * ck)) * deltas[i];
                const ak = a[i] / Math.pow(A + key + 1, alpha);
                values[i] = this.fixValueByFilterIDX(values[i] - ak * g, i);
            }
            const loss = this.loss(values);
            if (loss < bestLoss) {
                best = values.slice(0);
                bestLoss = loss;
            }
        }
        return { values: best, loss: bestLoss, called };
    }
    /**
     * Checks how much is the loss for the filter in RGB and HSL colors
     *
     * @private
     * @param {SPSAPayload['values']} filters
     * @returns {number}
     * @memberof Solver
     */
    loss(filters) {
        // Argument as an Array of percentages.
        const color = this.reusedColor;
        // Resetting the color to black in case
        // it was called more than once
        color.set(0, 0, 0);
        color.invert(filters[0] / 100);
        color.sepia(filters[1] / 100);
        color.saturate(filters[2] / 100);
        color.hueRotate(filters[3] * 3.6);
        color.brightness(filters[4] / 100);
        color.contrast(filters[5] / 100);
        const colorHSL = color.hsl();
        return (Math.abs(color.r - this.target.r) +
            Math.abs(color.g - this.target.g) +
            Math.abs(color.b - this.target.b) +
            Math.abs(colorHSL.h - this.targetHSL.h) +
            Math.abs(colorHSL.s - this.targetHSL.s) +
            Math.abs(colorHSL.l - this.targetHSL.l));
    }
    /**
     * Returns the CSS filter list for the received HEX color
     *
     * @private
     * @param {number[]} filters
     * @returns {string}
     * @memberof Solver
     */
    css(filters) {
        const formatCssFilterValueByMultiplier = (idx, multiplier = 1) => Math.round(filters[idx] * multiplier);
        return [
            `invert(${formatCssFilterValueByMultiplier(0)}%)`,
            `sepia(${formatCssFilterValueByMultiplier(1)}%)`,
            `saturate(${formatCssFilterValueByMultiplier(2)}%)`,
            `hue-rotate(${formatCssFilterValueByMultiplier(3, 3.6)}deg)`,
            `brightness(${formatCssFilterValueByMultiplier(4)}%)`,
            `contrast(${formatCssFilterValueByMultiplier(5)}%);`,
        ].join(' ');
    }
}
export { Solver };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29sdmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbm93Ym9hcmQtaWNvbi9zcmMvbGliL2hleC10by1jc3MtZmlsdGVyL3NvbHZlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBWWhDLE1BQU0sTUFBTTtJQU1WLFlBQVksTUFBYSxFQUFFLE9BQThCO1FBQ3ZELElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRTlCLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FDMUIsRUFBRTtRQUNGLG9DQUFvQztRQUNwQztZQUNFLHdCQUF3QixFQUFFLENBQUM7WUFDM0IsU0FBUyxFQUFFLEVBQUU7U0FDZCxFQUNELE9BQU8sQ0FDUixDQUFDO1FBRUYsZ0RBQWdEO1FBQ2hELDZDQUE2QztRQUM3QywrQkFBK0I7UUFDL0IsaURBQWlEO1FBQ2pELG1DQUFtQztRQUNuQyx3QkFBd0I7UUFDeEIsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILEtBQUs7UUFJSCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO1FBQ2xELE9BQU87WUFDTCxNQUFNLEVBQUUsTUFBTSxDQUFDLE1BQU07WUFDckIsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNO1lBQ3JCLElBQUksRUFBRSxNQUFNLENBQUMsSUFBSTtZQUNqQixNQUFNLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQ2hDLENBQUM7SUFDSixD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Q3NzQ29uZmlndXJhdGlvbiB9IGZyb20gJy4vaGV4LXRvLWNzcy1maWx0ZXInO1xuXG5pbnRlcmZhY2UgU1BTQVBheWxvYWQge1xuICAvKiogSG93IG1hbnkgdGltZXMgdGhlIHNjcmlwdCB3YXMgY2FsbGVkIHRvIHNvbHZlIHRoZSBjb2xvciAqL1xuICBjYWxsZWQ/OiBudW1iZXI7XG4gIC8qKiBQZXJjZW50YWdlIGxvc3MgdmFsdWUgZm9yIHRoZSBnZW5lcmF0ZWQgZmlsdGVyICovXG4gIGxvc3M6IG51bWJlcjtcbiAgLyoqIFBlcmNlbnRhZ2UgbG9zcyBwZXIgZWFjaCBjb2xvciB0eXBlIG9yZ2FuaXplZCBpbiBSR0I6IHJlZCwgZ3JlZW4sIGJsdWUsIGgsIHMsIGwuICovXG4gIHZhbHVlczogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xufVxuXG5jbGFzcyBTb2x2ZXIge1xuICBwcml2YXRlIHRhcmdldDogQ29sb3I7XG4gIHByaXZhdGUgdGFyZ2V0SFNMOiB7IGg6IG51bWJlcjsgczogbnVtYmVyOyBsOiBudW1iZXIgfTtcbiAgcHJpdmF0ZSByZXVzZWRDb2xvcjogQ29sb3I7XG4gIHByaXZhdGUgb3B0aW9uczogeyBhY2NlcHRhbmNlTG9zc1BlcmNlbnRhZ2U6IG51bWJlcjsgbWF4Q2hlY2tzOiBudW1iZXIgfSAmIEhleFRvQ3NzQ29uZmlndXJhdGlvbjtcblxuICBjb25zdHJ1Y3Rvcih0YXJnZXQ6IENvbG9yLCBvcHRpb25zOiBIZXhUb0Nzc0NvbmZpZ3VyYXRpb24pIHtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLnRhcmdldEhTTCA9IHRhcmdldC5oc2woKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7fSxcbiAgICAgIC8vIEFkZGluZyBkZWZhdWx0IHZhbHVlcyBmb3Igb3B0aW9uc1xuICAgICAge1xuICAgICAgICBhY2NlcHRhbmNlTG9zc1BlcmNlbnRhZ2U6IDUsXG4gICAgICAgIG1heENoZWNrczogMTUsXG4gICAgICB9LFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuXG4gICAgLy8gQWxsIHRoZSBjYWxjcyBkb25lIGJ5IHRoZSBsaWJyYXJ5IHRvIGdlbmVyYXRlXG4gICAgLy8gYSBDU1MgRmlsdGVyIGFyZSBiYXNlZCBvbiB0aGUgY29sb3IgYCMwMDBgXG4gICAgLy8gaW4gdGhpcyBjYXNlLCBgcmdiKDAsIDAsIDApYFxuICAgIC8vIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGJhY2tncm91bmQgb2YgdGhlIGVsZW1lbnRcbiAgICAvLyBpcyBgIzAwMGAgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuICAgIC8vIGFuZCBjb2xvciBzaW1pbGFyaXR5LlxuICAgIHRoaXMucmV1c2VkQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc29sdmVkIHZhbHVlcyBmb3IgdGhlXG4gICAqXG4gICAqIEByZXR1cm5zIHsoU1BTQVBheWxvYWQgJiB7IGZpbHRlcjogc3RyaW5nOyB9KX1cbiAgICogQG1lbWJlcm9mIFNvbHZlclxuICAgKi9cbiAgc29sdmUoKTogU1BTQVBheWxvYWQgJiB7XG4gICAgLyoqIENTUyBmaWx0ZXIgZ2VuZXJhdGVkIGJhc2VkIG9uIHRoZSBIZXggY29sb3IgKi9cbiAgICBmaWx0ZXI6IHN0cmluZztcbiAgfSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zb2x2ZU5hcnJvdyh0aGlzLnNvbHZlV2lkZSgpKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWVzOiByZXN1bHQudmFsdWVzLFxuICAgICAgY2FsbGVkOiByZXN1bHQuY2FsbGVkLFxuICAgICAgbG9zczogcmVzdWx0Lmxvc3MsXG4gICAgICBmaWx0ZXI6IHRoaXMuY3NzKHJlc3VsdC52YWx1ZXMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU29sdmUgd2lkZSB2YWx1ZXMgYmFzZWQgb24gdGhlIHdpZGUgdmFsdWVzIGZvciBSR0IgYW5kIEhTTCB2YWx1ZXNcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge1NQU0FQYXlsb2FkfVxuICAgKiBAbWVtYmVyb2YgU29sdmVyXG4gICAqL1xuICBwcml2YXRlIHNvbHZlV2lkZSgpOiBTUFNBUGF5bG9hZCB7XG4gICAgY29uc3QgQSA9IDU7XG4gICAgY29uc3QgYyA9IDE1O1xuICAgIC8vIFdpZGUgdmFsdWVzIGZvciBSR0IgYW5kIEhTTCB2YWx1ZXNcbiAgICAvLyB0aGUgdmFsdWVzIGluIHRoZSBvcmRlcjogW2ByYCwgYGdgLCBgYmAsIGBoYCwgYHNgLCBgbGBdXG4gICAgY29uc3QgYSA9IFs2MCwgMTgwLCAxODAwMCwgNjAwLCAxLjIsIDEuMl07XG5cbiAgICBsZXQgYmVzdCA9IHsgbG9zczogSW5maW5pdHkgfTtcbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgd2hpbGUgKGJlc3QubG9zcyA+IHRoaXMub3B0aW9ucy5hY2NlcHRhbmNlTG9zc1BlcmNlbnRhZ2UpIHtcbiAgICAgIGNvbnN0IGluaXRpYWxGaWx0ZXJWYWx1ZXM6IFNQU0FQYXlsb2FkWyd2YWx1ZXMnXSA9IFs1MCwgMjAsIDM3NTAsIDUwLCAxMDAsIDEwMF07XG4gICAgICBjb25zdCByZXN1bHQ6IFNQU0FQYXlsb2FkID0gdGhpcy5zcHNhKHtcbiAgICAgICAgQSxcbiAgICAgICAgYSxcbiAgICAgICAgYyxcbiAgICAgICAgdmFsdWVzOiBpbml0aWFsRmlsdGVyVmFsdWVzLFxuICAgICAgICAvLyBmb3Igd2lkZSB2YWx1ZXMgd2Ugc2hvdWxkIHVzZSB0aGUgZG91YmxlIG9mIHRyaWVzIGluXG4gICAgICAgIC8vIGNvbXBhcmlzb24gb2YgYHNvbHZlTmFycm93KClgIG1ldGhvZFxuICAgICAgICBtYXhUcmllc0luTG9vcDogMTAwMCxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVzdWx0Lmxvc3MgPCBiZXN0Lmxvc3MpIHtcbiAgICAgICAgYmVzdCA9IHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgY291bnRlciArPSAxO1xuICAgICAgaWYgKGNvdW50ZXIgPj0gdGhpcy5vcHRpb25zLm1heENoZWNrcykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYmVzdCwgeyBjYWxsZWQ6IGNvdW50ZXIgfSkgYXMgU1BTQVBheWxvYWQ7XG4gIH1cblxuICAvKipcbiAgICogU29sdmUgbmFycm93IHZhbHVlcyBiYXNlZCBvbiB0aGUgd2lkZSB2YWx1ZXMgZm9yIHRoZSBmaWx0ZXJcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTUFNBUGF5bG9hZH0gd2lkZVxuICAgKiBAcmV0dXJucyB7U1BTQVBheWxvYWR9XG4gICAqIEBtZW1iZXJvZiBTb2x2ZXJcbiAgICovXG4gIHByaXZhdGUgc29sdmVOYXJyb3cod2lkZTogU1BTQVBheWxvYWQpOiBTUFNBUGF5bG9hZCB7XG4gICAgY29uc3QgQSA9IHdpZGUubG9zcztcbiAgICBjb25zdCBjID0gMjtcbiAgICBjb25zdCBBMSA9IEEgKyAxO1xuICAgIC8vIE5hcnJvdyB2YWx1ZXMgZm9yIFJHQiBhbmQgSFNMIHZhbHVlc1xuICAgIC8vIHRoZSB2YWx1ZXMgaW4gdGhlIG9yZGVyOiBbYHJgLCBgZ2AsIGBiYCwgYGhgLCBgc2AsIGBsYF1cbiAgICBjb25zdCBhID0gWzAuMjUgKiBBMSwgMC4yNSAqIEExLCBBMSwgMC4yNSAqIEExLCAwLjIgKiBBMSwgMC4yICogQTFdO1xuICAgIHJldHVybiB0aGlzLnNwc2Eoe1xuICAgICAgQSxcbiAgICAgIGEsXG4gICAgICBjLFxuICAgICAgdmFsdWVzOiB3aWRlLnZhbHVlcyxcbiAgICAgIG1heFRyaWVzSW5Mb29wOiA1MDAsXG4gICAgICBjYWxsZWQ6IHdpZGUuY2FsbGVkLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmluYWwgdmFsdWUgYmFzZWQgb24gdGhlIGN1cnJlbnQgZmlsdGVyIG9yZGVyXG4gICAqIHRvIGdldCB0aGUgb3JkZXIsIHBsZWFzZSBjaGVjayB0aGUgcmV0dXJuZWQgdmFsdWVcbiAgICogaW4gYGNzcygpYCBtZXRob2RcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICogQG1lbWJlcm9mIFNvbHZlclxuICAgKi9cbiAgcHJpdmF0ZSBmaXhWYWx1ZUJ5RmlsdGVySURYKHZhbHVlOiBudW1iZXIsIGlkeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBsZXQgbWF4ID0gMTAwO1xuXG4gICAgLy8gRml4aW5nIG1heCwgbWluaW11bSBhbmQgdmFsdWUgYnkgZmlsdGVyXG4gICAgaWYgKGlkeCA9PT0gMiAvKiBzYXR1cmF0ZSAqLykge1xuICAgICAgbWF4ID0gNzUwMDtcbiAgICB9IGVsc2UgaWYgKGlkeCA9PT0gNCAvKiBicmlnaHRuZXNzICovIHx8IGlkeCA9PT0gNSAvKiBjb250cmFzdCAqLykge1xuICAgICAgbWF4ID0gMjAwO1xuICAgIH1cblxuICAgIGlmIChpZHggPT09IDMgLyogaHVlLXJvdGF0ZSAqLykge1xuICAgICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgIHZhbHVlICU9IG1heDtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgIHZhbHVlID0gbWF4ICsgKHZhbHVlICUgbWF4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2tpbmcgaWYgdmFsdWUgaXMgYmVsb3cgdGhlIG1pbmltdW0gb3IgYWJvdmVcbiAgICAvLyB0aGUgbWF4aW11bSBhbGxvd2VkIGJ5IGZpbHRlclxuICAgIGVsc2UgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgdmFsdWUgPSAwO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgIHZhbHVlID0gbWF4O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBwcml2YXRlIHNwc2Eoe1xuICAgIEEsXG4gICAgYSxcbiAgICBjLFxuICAgIHZhbHVlcyxcbiAgICBtYXhUcmllc0luTG9vcCA9IDUwMCxcbiAgICBjYWxsZWQgPSAwLFxuICB9OiB7XG4gICAgQTogbnVtYmVyO1xuICAgIGE6IG51bWJlcltdO1xuICAgIGM6IG51bWJlcjtcbiAgICB2YWx1ZXM6IFNQU0FQYXlsb2FkWyd2YWx1ZXMnXTtcbiAgICBtYXhUcmllc0luTG9vcDogbnVtYmVyO1xuICAgIGNhbGxlZD86IG51bWJlcjtcbiAgfSk6IFNQU0FQYXlsb2FkIHtcbiAgICBjb25zdCBhbHBoYSA9IDE7XG4gICAgY29uc3QgZ2FtbWEgPSAwLjE2NjY2NjY2NjY2NjY2NjY2O1xuXG4gICAgbGV0IGJlc3QgPSBudWxsO1xuICAgIGxldCBiZXN0TG9zcyA9IEluZmluaXR5O1xuXG4gICAgY29uc3QgZGVsdGFzID0gbmV3IEFycmF5KDYpIGFzIFNQU0FQYXlsb2FkWyd2YWx1ZXMnXTtcbiAgICBjb25zdCBoaWdoQXJncyA9IG5ldyBBcnJheSg2KSBhcyBTUFNBUGF5bG9hZFsndmFsdWVzJ107XG4gICAgY29uc3QgbG93QXJncyA9IG5ldyBBcnJheSg2KSBhcyBTUFNBUGF5bG9hZFsndmFsdWVzJ107XG5cbiAgICAvLyBTaXplIG9mIGFsbCBDU1MgZmlsdGVycyB0byBiZSBhcHBsaWVkIHRvIGdldCB0aGUgY29ycmVjdCBjb2xvclxuICAgIGNvbnN0IGZpbHRlcnNUb0JlQXBwbGllZFNpemUgPSA2O1xuXG4gICAgZm9yIChsZXQga2V5ID0gMDsga2V5IDwgbWF4VHJpZXNJbkxvb3A7IGtleSsrKSB7XG4gICAgICBjb25zdCBjayA9IGMgLyBNYXRoLnBvdyhrZXkgKyAxLCBnYW1tYSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcnNUb0JlQXBwbGllZFNpemU7IGkrKykge1xuICAgICAgICBkZWx0YXNbaV0gPSBNYXRoLnJhbmRvbSgpID4gMC41ID8gMSA6IC0xO1xuICAgICAgICBoaWdoQXJnc1tpXSA9IHZhbHVlc1tpXSArIGNrICogZGVsdGFzW2ldO1xuICAgICAgICBsb3dBcmdzW2ldID0gdmFsdWVzW2ldIC0gY2sgKiBkZWx0YXNbaV07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvc3NEaWZmID0gdGhpcy5sb3NzKGhpZ2hBcmdzKSAtIHRoaXMubG9zcyhsb3dBcmdzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyc1RvQmVBcHBsaWVkU2l6ZTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGcgPSAobG9zc0RpZmYgLyAoMiAqIGNrKSkgKiBkZWx0YXNbaV07XG4gICAgICAgIGNvbnN0IGFrID0gYVtpXSAvIE1hdGgucG93KEEgKyBrZXkgKyAxLCBhbHBoYSk7XG4gICAgICAgIHZhbHVlc1tpXSA9IHRoaXMuZml4VmFsdWVCeUZpbHRlcklEWCh2YWx1ZXNbaV0gLSBhayAqIGcsIGkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb3NzID0gdGhpcy5sb3NzKHZhbHVlcyk7XG4gICAgICBpZiAobG9zcyA8IGJlc3RMb3NzKSB7XG4gICAgICAgIGJlc3QgPSB2YWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgIGJlc3RMb3NzID0gbG9zcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyB2YWx1ZXM6IGJlc3QsIGxvc3M6IGJlc3RMb3NzLCBjYWxsZWQgfSBhcyBTUFNBUGF5bG9hZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaG93IG11Y2ggaXMgdGhlIGxvc3MgZm9yIHRoZSBmaWx0ZXIgaW4gUkdCIGFuZCBIU0wgY29sb3JzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U1BTQVBheWxvYWRbJ3ZhbHVlcyddfSBmaWx0ZXJzXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBTb2x2ZXJcbiAgICovXG4gIHByaXZhdGUgbG9zcyhmaWx0ZXJzOiBTUFNBUGF5bG9hZFsndmFsdWVzJ10pOiBudW1iZXIge1xuICAgIC8vIEFyZ3VtZW50IGFzIGFuIEFycmF5IG9mIHBlcmNlbnRhZ2VzLlxuICAgIGNvbnN0IGNvbG9yID0gdGhpcy5yZXVzZWRDb2xvcjtcblxuICAgIC8vIFJlc2V0dGluZyB0aGUgY29sb3IgdG8gYmxhY2sgaW4gY2FzZVxuICAgIC8vIGl0IHdhcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2VcbiAgICBjb2xvci5zZXQoMCwgMCwgMCk7XG5cbiAgICBjb2xvci5pbnZlcnQoZmlsdGVyc1swXSAvIDEwMCk7XG4gICAgY29sb3Iuc2VwaWEoZmlsdGVyc1sxXSAvIDEwMCk7XG4gICAgY29sb3Iuc2F0dXJhdGUoZmlsdGVyc1syXSAvIDEwMCk7XG4gICAgY29sb3IuaHVlUm90YXRlKGZpbHRlcnNbM10gKiAzLjYpO1xuICAgIGNvbG9yLmJyaWdodG5lc3MoZmlsdGVyc1s0XSAvIDEwMCk7XG4gICAgY29sb3IuY29udHJhc3QoZmlsdGVyc1s1XSAvIDEwMCk7XG5cbiAgICBjb25zdCBjb2xvckhTTCA9IGNvbG9yLmhzbCgpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIE1hdGguYWJzKGNvbG9yLnIgLSB0aGlzLnRhcmdldC5yKSArXG4gICAgICBNYXRoLmFicyhjb2xvci5nIC0gdGhpcy50YXJnZXQuZykgK1xuICAgICAgTWF0aC5hYnMoY29sb3IuYiAtIHRoaXMudGFyZ2V0LmIpICtcbiAgICAgIE1hdGguYWJzKGNvbG9ySFNMLmggLSB0aGlzLnRhcmdldEhTTC5oKSArXG4gICAgICBNYXRoLmFicyhjb2xvckhTTC5zIC0gdGhpcy50YXJnZXRIU0wucykgK1xuICAgICAgTWF0aC5hYnMoY29sb3JIU0wubCAtIHRoaXMudGFyZ2V0SFNMLmwpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBDU1MgZmlsdGVyIGxpc3QgZm9yIHRoZSByZWNlaXZlZCBIRVggY29sb3JcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gZmlsdGVyc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgU29sdmVyXG4gICAqL1xuICBwcml2YXRlIGNzcyhmaWx0ZXJzOiBudW1iZXJbXSk6IHN0cmluZyB7XG4gICAgY29uc3QgZm9ybWF0Q3NzRmlsdGVyVmFsdWVCeU11bHRpcGxpZXIgPSAoaWR4OiBudW1iZXIsIG11bHRpcGxpZXIgPSAxKTogbnVtYmVyID0+XG4gICAgICBNYXRoLnJvdW5kKGZpbHRlcnNbaWR4XSAqIG11bHRpcGxpZXIpO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIGBpbnZlcnQoJHtmb3JtYXRDc3NGaWx0ZXJWYWx1ZUJ5TXVsdGlwbGllcigwKX0lKWAsXG4gICAgICBgc2VwaWEoJHtmb3JtYXRDc3NGaWx0ZXJWYWx1ZUJ5TXVsdGlwbGllcigxKX0lKWAsXG4gICAgICBgc2F0dXJhdGUoJHtmb3JtYXRDc3NGaWx0ZXJWYWx1ZUJ5TXVsdGlwbGllcigyKX0lKWAsXG4gICAgICBgaHVlLXJvdGF0ZSgke2Zvcm1hdENzc0ZpbHRlclZhbHVlQnlNdWx0aXBsaWVyKDMsIDMuNil9ZGVnKWAsXG4gICAgICBgYnJpZ2h0bmVzcygke2Zvcm1hdENzc0ZpbHRlclZhbHVlQnlNdWx0aXBsaWVyKDQpfSUpYCxcbiAgICAgIGBjb250cmFzdCgke2Zvcm1hdENzc0ZpbHRlclZhbHVlQnlNdWx0aXBsaWVyKDUpfSUpO2AsXG4gICAgXS5qb2luKCcgJyk7XG4gIH1cbn1cblxuZXhwb3J0IHsgU29sdmVyIH07XG4iXX0=